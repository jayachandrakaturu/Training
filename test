import { Component, TemplateRef, ViewContainerRef } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { HasAccessDirective } from './has-access.directive';
import { UserSessionService } from '../../services/user-session.service';

// Mock component for directive usage
@Component({
  template: `
    <div *appHasAccess="allowedRoles">Protected Content</div>
    <ng-template #testTemplate>Template Content</ng-template>
  `,
  standalone: true,
  imports: [HasAccessDirective]
})
class TestComponent {
  allowedRoles: string[] = ['admin', 'editor'];
}

// Group interface for stronger typing
interface UserGroup {
  groupCd: string;
  name: string;
}

// Mocked version of UserSessionService
class MockUserSessionService {
  private mockRoles: string[] = [];
  private mockGroups: UserGroup[] = [];

  setRoles(roles: string[]): void {
    this.mockRoles = roles;
  }

  setGroups(groups: UserGroup[]): void {
    this.mockGroups = groups;
  }

  getAllRoles(): string[] | undefined {
    return this.mockRoles;
  }

  getUserGroups(): UserGroup[] | undefined {
    return this.mockGroups;
  }
}

describe('HasAccessDirective', () => {
  let directive: HasAccessDirective;
  let mockUserSessionService: MockUserSessionService;
  let templateRef: TemplateRef<unknown>;
  let viewContainerRef: jasmine.SpyObj<ViewContainerRef>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [TestComponent, HasAccessDirective],
      providers: [
        { provide: UserSessionService, useClass: MockUserSessionService }
      ]
    });

    mockUserSessionService = TestBed.inject(UserSessionService) as unknown as MockUserSessionService;

    const fixture = TestBed.createComponent(TestComponent);
    fixture.detectChanges();

    const templateElement = fixture.debugElement.references['testTemplate'];
    if (!templateElement) {
      throw new Error('testTemplate not found in template');
    }
    templateRef = templateElement as TemplateRef<unknown>;

    viewContainerRef = jasmine.createSpyObj<ViewContainerRef>('ViewContainerRef', [
      'clear',
      'createEmbeddedView'
    ]);
  });

  // ✅ Directive Creation Tests
  describe('Directive Creation', () => {
    it('should create an instance', () => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
      expect(directive).toBeTruthy();
    });

    it('should have required appHasAccess input', () => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
      directive.appHasAccess = ['admin'];
      expect(directive.appHasAccess).toEqual(['admin']);
    });
  });

  // ✅ Initialization
  describe('ngOnInit', () => {
    beforeEach(() => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
    });

    it('should call updateView on initialization', () => {
      spyOn(directive, 'updateView');
      directive.ngOnInit();
      expect(directive.updateView).toHaveBeenCalled();
    });
  });

  // ✅ Role-based Access
  describe('updateView - Role Based Access', () => {
    beforeEach(() => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
    });

    it('should show content when user has matching role', () => {
      directive.appHasAccess = ['admin', 'editor'];
      mockUserSessionService.setRoles(['admin', 'user']);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).toHaveBeenCalledWith(templateRef);
    });

    it('should not show content when user has no matching roles', () => {
      directive.appHasAccess = ['admin', 'editor'];
      mockUserSessionService.setRoles(['guest']);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).not.toHaveBeenCalled();
    });
  });

  // ✅ Group-based Access
  describe('updateView - Group Based Access', () => {
    beforeEach(() => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
    });

    it('should show content when user has matching group', () => {
      directive.appHasAccess = ['admin-group'];
      mockUserSessionService.setGroups([{ groupCd: 'admin-group', name: 'Admin Group' }]);
      mockUserSessionService.setRoles([]);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).toHaveBeenCalledWith(templateRef);
    });

    it('should not show content when user has no matching groups', () => {
      directive.appHasAccess = ['admin-group', 'editor-group'];
      mockUserSessionService.setGroups([{ groupCd: 'guest-group', name: 'Guest Group' }]);
      mockUserSessionService.setRoles([]);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).not.toHaveBeenCalled();
    });
  });

  // ✅ Combined Role and Group Access
  describe('updateView - Combined Role and Group Access', () => {
    beforeEach(() => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
    });

    it('should show content when user has matching role or group', () => {
      directive.appHasAccess = ['admin', 'editor-group'];
      mockUserSessionService.setRoles(['admin']);
      mockUserSessionService.setGroups([{ groupCd: 'guest-group', name: 'Guest Group' }]);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).toHaveBeenCalledWith(templateRef);
    });
  });

  // ✅ Edge Cases
  describe('Edge Cases', () => {
    beforeEach(() => {
      directive = new HasAccessDirective(templateRef, viewContainerRef, mockUserSessionService);
    });

    it('should handle empty required roles array', () => {
      directive.appHasAccess = [];
      mockUserSessionService.setRoles(['admin']);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).not.toHaveBeenCalled();
    });

    it('should handle undefined roles/groups from service', () => {
      directive.appHasAccess = ['admin'];
      spyOn(mockUserSessionService, 'getAllRoles').and.returnValue(undefined);
      spyOn(mockUserSessionService, 'getUserGroups').and.returnValue(undefined);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).not.toHaveBeenCalled();
    });

    it('should handle null roles/groups from service', () => {
      directive.appHasAccess = ['admin'];
      spyOn(mockUserSessionService, 'getAllRoles').and.returnValue(null as unknown as string[]);
      spyOn(mockUserSessionService, 'getUserGroups').and.returnValue(null as unknown as UserGroup[]);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).not.toHaveBeenCalled();
    });

    it('should handle case sensitivity in role/group matching', () => {
      directive.appHasAccess = ['Admin', 'EDITOR'];
      mockUserSessionService.setRoles(['admin', 'editor']);
      mockUserSessionService.setGroups([{ groupCd: 'admin', name: 'Admin Group' }]);

      directive.updateView();

      expect(viewContainerRef.clear).toHaveBeenCalled();
      expect(viewContainerRef.createEmbeddedView).not.toHaveBeenCalled();
    });
  });

  // ✅ Integration Test
  describe('Integration Test', () => {
    it('should show/hide content in template based on user roles', () => {
      const fixture = TestBed.createComponent(TestComponent);
      mockUserSessionService.setRoles(['admin']);
      mockUserSessionService.setGroups([]);

      fixture.detectChanges();

      const compiled = fixture.nativeElement as HTMLElement;
      expect(compiled.textContent).toContain('Protected Content');

      mockUserSessionService.setRoles(['guest']);
      fixture.detectChanges();

      expect(compiled.textContent).not.toContain('Protected Content');
    });
  });
});
